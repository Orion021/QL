<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Glass QR Generator — with white padding</title>

  <style>
    :root{
      --bg-1:#071022; --bg-2:#08131f; --glass-1:rgba(255,255,255,0.055);
      --glass-2:rgba(255,255,255,0.015); --muted:rgba(230,238,248,0.72);
      --accent-a:#60d8ff; --accent-b:#a78bfa; --radius:16px; --pad:18px;
    }
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Roboto,Arial;
      background:
        radial-gradient(800px 320px at 8% 10%, rgba(96,216,255,0.035), transparent 6%),
        radial-gradient(800px 320px at 92% 86%, rgba(167,139,250,0.03), transparent 6%),
        linear-gradient(180deg,var(--bg-1),var(--bg-2));
      color:#e6eef8;-webkit-font-smoothing:antialiased;padding:36px 22px;box-sizing:border-box;}
    .wrap{max-width:1100px;margin:0 auto}
    header{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:18px}
    .brand{display:flex;gap:12px;align-items:center}.logo{width:56px;height:56px;border-radius:12px;display:grid;place-items:center;font-weight:700;color:#041224;background:linear-gradient(135deg,var(--accent-a),var(--accent-b));box-shadow:0 10px 28px rgba(84,93,255,0.10);font-size:18px}
    h1{margin:0;font-size:18px}.lead{margin:0;color:var(--muted);font-size:13px}
    .layout{display:grid;grid-template-columns:1fr 420px;gap:20px;align-items:start}
    .card{background:linear-gradient(180deg,var(--glass-1),var(--glass-2));border:1px solid rgba(255,255,255,0.06);border-radius:var(--radius);padding:var(--pad);backdrop-filter:blur(10px) saturate(140%);-webkit-backdrop-filter:blur(10px) saturate(140%);box-shadow:0 8px 30px rgba(2,6,23,0.55);position:relative}
    .controls{display:flex;flex-direction:column;gap:14px}
    label{font-size:13px;color:var(--muted);margin-bottom:8px;display:block}
    textarea.input{width:100%;min-height:160px;resize:vertical;border-radius:12px;padding:12px;border:1px solid rgba(255,255,255,0.04);background:rgba(255,255,255,0.02);color:inherit;outline:none;font-family:ui-monospace,Menlo,monospace;font-size:14px;box-sizing:border-box}
    .form-row{display:flex;gap:10px;align-items:center}.form-row> *{flex:1;min-width:0}
    input[type="number"],select,input[type="color"],.btn{border-radius:10px;padding:10px 12px;border:1px solid rgba(255,255,255,0.04);background:rgba(255,255,255,0.02);color:inherit;outline:none;font-size:13px;box-sizing:border-box}
    .btn{display:inline-flex;align-items:center;gap:8px;cursor:pointer;font-weight:600;justify-content:center;min-height:42px;transition:transform .12s,box-shadow .12s,opacity .12s}
    .btn.primary{background:linear-gradient(90deg,var(--accent-a),var(--accent-b));color:#041224;box-shadow:0 12px 30px rgba(96,216,255,0.08)}
    .controls .actions{display:flex;gap:10px;flex-wrap:wrap}
    .hint{font-size:13px;color:var(--muted)}
    .preview{display:flex;flex-direction:column;gap:12px;align-items:stretch}
    .qr-frame{border-radius:12px;padding:18px;min-height:380px;display:flex;align-items:center;justify-content:center;border:1px solid rgba(255,255,255,0.04);background:linear-gradient(180deg, rgba(255,255,255,0.012), rgba(255,255,255,0.01));box-sizing:border-box}
    .qr-preview{width:100%;max-width:360px;height:360px;display:grid;place-items:center;background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));border-radius:10px;overflow:hidden;box-sizing:border-box}
    .qr-preview img{max-width:100%;max-height:100%;display:block}
    .meta{display:flex;justify-content:space-between;align-items:center;gap:10px}
    .meta .small{font-size:13px;color:var(--muted)}
    .error{color:#ffb4b4;background:rgba(255,80,80,0.06);padding:8px;border-radius:8px;font-size:13px;border:1px solid rgba(255,80,80,0.08)}
    @media (max-width:980px){.layout{grid-template-columns:1fr}.preview{order:-1}.qr-frame{min-height:320px}.qr-preview{width:320px;height:320px}header{flex-direction:column;align-items:flex-start;gap:10px}}
    @media (max-width:420px){.qr-preview{width:260px;height:260px}.qr-frame{min-height:300px;padding:14px}.textarea.input{min-height:140px}}
    /* MOBILE-FRIENDLY TWEAKS (paste near end of your stylesheet) */

/* Increase tappable area, full-width buttons on small screens */
.btn {
  min-height:48px;          /* larger touch target */
  padding:12px 14px;
  font-size:15px;
  border-radius:12px;
}

/* Make action buttons stack and become full width on narrow screens */
@media (max-width:520px) {
  .controls .actions {
    flex-direction: column;
    gap:10px;
  }
  .controls .actions .btn { width:100%; }

  /* Reduce page padding so content uses more viewport */
  html, body { padding:20px 12px; }

  /* Make textarea shorter on very small screens */
  textarea.input { min-height:120px; font-size:15px; padding:10px; }

  /* Scale the QR preview to use most of the screen, while keeping a max */
  .qr-preview {
    width: 88vw !important;
    height: 88vw !important;
    max-width: 420px;
    max-height: 420px;
  }

  /* Slightly increase labels and hint legibility */
  label, .hint, .small { font-size:15px; }

  /* Slightly reduce card padding */
  .card { padding:14px; border-radius:14px; }

  /* Ensure form rows wrap cleanly */
  .form-row { flex-direction: column; align-items:stretch; }
  .form-row > * { width:100%; }
}

/* Improve tap feedback */
.btn:active { transform: translateY(1px) scale(0.997); }

/* Make QR image drag/longpress friendly on mobile */
.qr-preview img { touch-action: manipulation; -webkit-user-drag: none; -webkit-touch-callout: none; }

/* Optional: larger focus ring for accessibility on small devices */
.tile:focus, .btn:focus, input:focus, textarea:focus, select:focus {
  box-shadow: 0 8px 28px rgba(96,216,255,0.12);
  outline: none;
}

  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="brand">
        <div class="logo">QR</div>
        <div>
          <h1>Glass QR Generator — white padding</h1>
          <!--<p class="lead">Generates PNG QR with a guaranteed white quiet zone (padding) so scanners work reliably.</p>-->
        </div>
      </div>

      <div style="display:flex;gap:12px;align-items:center">
        <div class="hint">Output: PNG • Drag image to save</div>
      </div>
    </header>

    <main class="layout">
      <section class="card controls" aria-labelledby="input-label">
        <div>
          <label id="input-label">Text / URL / Data to encode</label>
          <textarea id="text" class="input" placeholder="Enter URL (https://...), vCard, JSON, or any text..."></textarea>
        </div>

        <div class="form-row">
          <div>
            <label>Size (px) — final image size including padding</label>
            <input id="size" type="number" min="128" max="4096" value="720" />
          </div>
          <div>
            <label>Error correction</label>
            <select id="ec">
              <option value="L">L — Low (7%)</option>
              <option value="M" selected>M — Medium (15%)</option>
              <option value="Q">Q — Quartile (25%)</option>
              <option value="H">H — High (30%)</option>
            </select>
          </div>
        </div>

        <div class="form-row">
          <div>
            <label>Padding (px) — white quiet zone around QR</label>
            <input id="padding" type="number" min="8" max="400" value="20" />
          </div>
          <div>
            <label>Dark color (modules)</label>
            <input id="darkColor" type="color" value="#07131f" />
          </div>
        </div>

        <div class="form-row">
          <div>
            <label>Background color (will be replaced by white in final PNG)</label>
            <input id="lightColor" type="color" value="#ffffff" />
          </div>
          <div style="display:flex;align-items:flex-end;gap:8px">
            <div style="width:100%">
              <div style="font-size:12px;color:var(--muted);margin-bottom:6px">Actions</div>
              <div style="display:flex;gap:8px">
                <button id="generate" class="btn primary">Generate QR</button>
                <button id="download" class="btn" disabled>Download PNG</button>
                <button id="copyData" class="btn">Copy text</button>
                <button id="clear" class="btn">Clear</button>
              </div>
            </div>
          </div>
        </div>

        <div style="margin-top:10px;" class="hint">Tip: Padding ensures QR has a white quiet zone — scanners rely on that. Default 20 px is safe; increase if your QR touches real-world edges.</div>
        <div id="loaderStatus" style="margin-top:10px;font-size:13px;color:var(--muted)"></div>
        <div id="libError" style="margin-top:10px;display:none"></div>
      </section>

      <aside class="card preview" aria-live="polite">
        <div class="qr-frame">
          <div class="qr-preview" id="qrPreview" aria-hidden="false">
            <div id="placeholder" style="text-align:center;color:var(--muted);padding:12px">
              <div style="font-weight:600;margin-bottom:8px">Preview</div>
              <div style="font-size:13px">No QR yet — paste text and click Generate</div>
            </div>
          </div>
        </div>

        <div class="meta">
          <div class="small" id="qrInfo">Size: — • EC: —</div>
          <div style="display:flex;gap:8px">
            <button id="openPng" class="btn" disabled>Open PNG</button>
            <button id="copyUri" class="btn" disabled>Copy image URL</button>
          </div>
        </div>
      </aside>
    </main>
  </div>

  <script>
  /*******************************
   * Resilient loader + generator
   *******************************/
  const CDN_URLS = [
    'https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js',
    'https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js',
    'https://unpkg.com/qrcodejs@1.0.0/qrcode.min.js'
  ];
  const loaderStatus = document.getElementById('loaderStatus');
  const libErrorDiv = document.getElementById('libError');
  function setLoaderStatus(text){ loaderStatus.textContent = text; }
  function showLibError(message){
    libErrorDiv.style.display = 'block';
    libErrorDiv.innerHTML = '<div class="error"><strong>QR library failed to load:</strong><div style="margin-top:6px;">' + message + '</div><div style="margin-top:8px;font-size:13px;color:var(--muted)">If you are offline or your network blocks CDNs, either host the library locally or ask me to inline it into this file.</div></div>';
  }
  function loadScript(url, timeout = 9000){
    return new Promise((resolve, reject) => {
      const s = document.createElement('script');
      let done = false;
      s.src = url;
      s.async = true;
      s.onload = () => { if (!done) { done = true; resolve(url); } };
      s.onerror = () => { if (!done) { done = true; reject(new Error('Failed to load ' + url)); } };
      document.head.appendChild(s);
      setTimeout(() => { if (!done) { done = true; reject(new Error('Timed out ' + url)); } }, timeout);
    });
  }
  async function ensureQRCodeLibrary(){
    if (window.QRCode && window.QRCode.CorrectLevel) { setLoaderStatus('QR library ready.'); return true; }
    setLoaderStatus('Loading QR library from CDN...');
    for (let url of CDN_URLS){
      setLoaderStatus('Trying: ' + url);
      try {
        await loadScript(url);
        await new Promise(r=>setTimeout(r,40));
        if (window.QRCode && window.QRCode.CorrectLevel) { setLoaderStatus('Loaded from: ' + url); return true; }
      } catch(e){
        console.warn('load fail', url, e);
      }
    }
    setLoaderStatus('All CDN attempts failed.');
    showLibError('Tried cdnjs / jsDelivr / unpkg but could not load qrcodejs. See console/network.');
    console.error('Failed to load qrcodejs from configured CDNs.');
    return false;
  }
  // Start loading early
  ensureQRCodeLibrary();

  // Debounce helper
  function debounce(fn, wait){ let t; return (...a)=>{ clearTimeout(t); t = setTimeout(()=>fn(...a), wait); }; }

  window.addEventListener('load', () => {
    const textEl = document.getElementById('text');
    const sizeEl = document.getElementById('size');
    const ecEl = document.getElementById('ec');
    const darkColorEl = document.getElementById('darkColor');
    const lightColorEl = document.getElementById('lightColor');
    const paddingEl = document.getElementById('padding');

    const generateBtn = document.getElementById('generate');
    const downloadBtn = document.getElementById('download');
    const copyDataBtn = document.getElementById('copyData');
    const clearBtn = document.getElementById('clear');

    const qrPreview = document.getElementById('qrPreview');
    const placeholder = document.getElementById('placeholder');
    const qrInfo = document.getElementById('qrInfo');
    const openPng = document.getElementById('openPng');
    const copyUri = document.getElementById('copyUri');

    let lastDataUrl = null;
    let lastText = '';

    function sanitizeFileName(text){ return 'qr-' + (new Date()).toISOString().replace(/[:.]/g,'-') + '.png'; }

    // When the QR library produces an image/canvas/table, we want to convert to a final PNG
    // that has white padding (quiet zone) of paddingPx around the QR modules.
    async function renderQRWithPadding(text, finalSize, paddingPx, darkColor, lightColor, ecLevel){
      // ensure library
      const ok = await ensureQRCodeLibrary();
      if (!ok) throw new Error('QR library not available');

      // validate sizes
      finalSize = Number(finalSize) || 512;
      paddingPx = Number(paddingPx) || 20;
      if (!isFinite(finalSize) || finalSize < 128 || finalSize > 4096) throw new Error('Invalid final size (128–4096).');
      if (!isFinite(paddingPx) || paddingPx < 0 || paddingPx * 2 >= finalSize) throw new Error('Invalid padding. Must be >=0 and less than half the size.');

      // inner QR area where modules will be drawn
      const innerSize = finalSize - 2 * paddingPx;
      if (innerSize <= 0) throw new Error('Padding too large for selected final size.');

      // create temporary container and ask qrcodejs to render QR at innerSize
      const tmp = document.createElement('div');

      try {
        new QRCode(tmp, {
          text,
          width: innerSize,
          height: innerSize,
          colorDark: darkColor,
          colorLight: lightColor,
          correctLevel: {
            'L': QRCode.CorrectLevel.L,
            'M': QRCode.CorrectLevel.M,
            'Q': QRCode.CorrectLevel.Q,
            'H': QRCode.CorrectLevel.H
          }[ecLevel] || QRCode.CorrectLevel.M
        });
      } catch (err){
        console.error('qrcodejs create error', err);
        throw err;
      }

      // wait a frame so children exist
      await new Promise(r => requestAnimationFrame(r));

      // Try to extract an image/canvas/table
      const img = tmp.querySelector('img');
      const canvas = tmp.querySelector('canvas');
      const table = tmp.querySelector('table');

      // Final canvas of size finalSize, fill white background
      const finalCanvas = document.createElement('canvas');
      finalCanvas.width = finalCanvas.height = finalSize;
      const ctx = finalCanvas.getContext('2d');

      // Ensure white background (quiet zone)
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0,0,finalSize,finalSize);

      // Helper: draw an existing canvas or image onto finalCanvas centered inside padding
      function drawSourceToFinal(srcCanvasOrImage){
        try {
          ctx.drawImage(srcCanvasOrImage, paddingPx, paddingPx, innerSize, innerSize);
        } catch (err){
          console.error('drawImage failed', err);
          // fallback - fill blank
          ctx.fillStyle = '#ffffff';
          ctx.fillRect(0,0,finalSize,finalSize);
        }
      }

      if (img && img.src) {
        // Ensure image is loaded before drawing
        if (img.complete && img.naturalWidth) {
          drawSourceToFinal(img);
          return finalCanvas.toDataURL('image/png');
        } else {
          // load via a new Image to be safe
          const loader = new Image();
          loader.crossOrigin = 'anonymous';
          return new Promise((resolve, reject) => {
            loader.onload = () => { drawSourceToFinal(loader); resolve(finalCanvas.toDataURL('image/png')); };
            loader.onerror = () => { // fallback
              console.warn('Failed loading qrcode image element, falling back to table/canvas.');
              if (canvas) { drawSourceToFinal(canvas); resolve(finalCanvas.toDataURL('image/png')); }
              else if (table) { const tdata = rasterizeTableToCanvas(table, innerSize, darkColor, lightColor); drawSourceToFinal(tdata); resolve(finalCanvas.toDataURL('image/png')); }
              else resolve(finalCanvas.toDataURL('image/png'));
            };
            loader.src = img.src;
          });
        }
      }

      if (canvas) {
        // draw canvas onto final
        drawSourceToFinal(canvas);
        return finalCanvas.toDataURL('image/png');
      }

      if (table) {
        // rasterize table to a temporary canvas, then draw
        const raster = rasterizeTableToCanvas(table, innerSize, darkColor, lightColor);
        drawSourceToFinal(raster);
        return finalCanvas.toDataURL('image/png');
      }

      // fallback: return blank white PNG
      return finalCanvas.toDataURL('image/png');
    }

    // Convert a qrcodejs table to a canvas sized 'size' (inner size)
    function rasterizeTableToCanvas(table, size, darkColor, lightColor){
      const rows = Array.from(table.rows || []);
      const modules = rows.length || 21;
      const cellSize = size / modules;
      const c = document.createElement('canvas');
      c.width = c.height = size;
      const ctx = c.getContext('2d');
      ctx.fillStyle = lightColor || '#fff';
      ctx.fillRect(0,0,size,size);
      rows.forEach((row, rIndex) => {
        Array.from(row.cells).forEach((cell, cIndex) => {
          const bg = window.getComputedStyle(cell).backgroundColor;
          const isDark = (bg && bg !== 'transparent' && !/rgba?\(0, 0, 0, 0\)/.test(bg)) || cell.innerHTML.trim() !== '';
          if (isDark) {
            ctx.fillStyle = darkColor || '#000';
            ctx.fillRect(Math.round(cIndex * cellSize), Math.round(rIndex * cellSize), Math.ceil(cellSize), Math.ceil(cellSize));
          }
        });
      });
      return c;
    }

    // UI helpers: show preview and set download state
    function setPreviewImage(dataUrl, size, ec, text){
      qrPreview.innerHTML = '';
      const img = document.createElement('img');
      img.src = dataUrl;
      img.alt = 'Generated QR';
      img.setAttribute('draggable','true');
      img.style.maxWidth = '100%';
      img.style.maxHeight = '100%';
      qrPreview.appendChild(img);

      lastDataUrl = dataUrl;
      lastText = text || lastText;
      downloadBtn.disabled = false;
      openPng.disabled = false;
      copyUri.disabled = false;
      libErrorDiv.style.display = 'none';
      qrInfo.textContent = `Size: ${size}px • Padding: ${Number(paddingEl.value)||0}px • EC: ${ec} • ${ (lastText.length>80) ? lastText.slice(0,80)+'…' : lastText}`;
    }

    function clearPreview(){
      qrPreview.innerHTML = '';
      qrPreview.appendChild(placeholder);
      lastDataUrl = null;
      downloadBtn.disabled = true;
      openPng.disabled = true;
      copyUri.disabled = true;
      qrInfo.textContent = 'Size: — • EC: —';
    }

    // Generate flow
    async function generateNow({ focus=false } = {}){
      const text = (textEl.value || '').trim();
      if (!text) { clearPreview(); return; }
      const finalSize = Number(sizeEl.value) || 720;
      const paddingPx = Number(paddingEl.value) || 20;
      const ec = ecEl.value || 'M';
      const dark = darkColorEl.value || '#07131f';
      const light = lightColorEl.value || '#ffffff';

      // Basic validations
      if (paddingPx*2 >= finalSize) { alert('Padding too large for chosen size. Reduce padding or increase size.'); return; }
      generateBtn.disabled = true;
      generateBtn.textContent = 'Generating...';

      try {
        const dataUrl = await renderQRWithPadding(text, finalSize, paddingPx, dark, light, ec);
        setPreviewImage(dataUrl, finalSize, ec, text);
      } catch (err){
        console.error('Failed to generate QR', err);
        libErrorDiv.style.display = 'block';
        libErrorDiv.innerHTML = '<div class="error"><strong>Failed to generate QR:</strong><div style="margin-top:6px;">' + (err && err.message ? err.message : 'Unknown error') + '</div></div>';
      } finally {
        generateBtn.disabled = false;
        generateBtn.textContent = 'Generate QR';
        if (focus) generateBtn.focus();
      }
    }

    // Debounced live preview (600ms)
    const livePreview = debounce(() => {
      if (textEl.value.trim()) generateNow();
    }, 600);

    // Event wiring
    generateBtn.addEventListener('click', () => generateNow({ focus:true }));

    textEl.addEventListener('keydown', (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') { e.preventDefault(); generateNow({ focus:true }); }
    });
    textEl.addEventListener('input', livePreview);

    [sizeEl, ecEl, darkColorEl, lightColorEl, paddingEl].forEach(el => el.addEventListener('change', () => { if (textEl.value.trim()) generateNow(); }));

    downloadBtn.addEventListener('click', () => {
      if (!lastDataUrl) return;
      const a = document.createElement('a');
      a.href = lastDataUrl;
      a.download = sanitizeFileName(lastText || '');
      document.body.appendChild(a);
      a.click();
      a.remove();
    });

    openPng.addEventListener('click', () => {
      if (!lastDataUrl) return alert('Generate a QR first.');
      window.open(lastDataUrl, '_blank', 'noopener');
    });

    copyUri.addEventListener('click', async () => {
      if (!lastDataUrl) return alert('Generate a QR first.');
      try {
        await navigator.clipboard.writeText(lastDataUrl);
        copyUri.textContent = 'Copied!';
        setTimeout(()=> copyUri.textContent = 'Copy image URL', 1200);
      } catch (e) { alert('Copy failed — you can open PNG and save manually.'); }
    });

    copyDataBtn.addEventListener('click', async () => {
      const v = textEl.value || '';
      if (!v) return;
      try {
        await navigator.clipboard.writeText(v);
        copyDataBtn.textContent = 'Copied';
        setTimeout(()=> copyDataBtn.textContent = 'Copy text', 1000);
      } catch { alert('Copy failed. Select and copy manually.'); }
    });

    clearBtn.addEventListener('click', () => { textEl.value = ''; clearPreview(); textEl.focus(); });

    // Accessibility: Enter/Space on buttons
    [generateBtn, downloadBtn, openPng, copyUri, copyDataBtn, clearBtn].forEach(b => {
      b.addEventListener('keydown', (e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); b.click(); } });
    });

    // Paste heuristic: auto-generate for URLs
    textEl.addEventListener('paste', () => {
      setTimeout(() => {
        const v = textEl.value.trim();
        if (/^https?:\/\//i.test(v) || /^www\./i.test(v)) { generateNow(); }
      }, 50);
    });

    // initial state
    clearPreview();
    generateBtn.disabled = false;
  });
  </script>
</body>
</html>
